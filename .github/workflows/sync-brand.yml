name: Sync Brand Assets (Polling)

on:
  schedule:
    # Run daily at 8:00 UTC
    - cron: '0 8 * * *'
  workflow_dispatch:

jobs:
  check-and-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Website
        uses: actions/checkout@v4

      - name: Check for Updates
        id: check
        env:
          GH_TOKEN: ${{ secrets.BRAND_REPO_READ_TOKEN }}
        run: |
          set -euo pipefail

          # 1. Get Local Version
          LOCAL_VERSION=$(jq -r .version src/data/brand-version.json)
          echo "Current local version: $LOCAL_VERSION"

          # 2. Get Remote Version (Latest Release Tag)
          # We use the GitHub CLI to fetch the latest release tag from the brand repo
          REMOTE_VERSION=$(gh release view --repo bitcraft-apps/bitcraft-brand --json tagName -q .tagName)
          echo "Latest remote version: $REMOTE_VERSION"

          # 3. Compare
          # Normalize versions by removing leading 'v' if present
          LOCAL_CLEAN=${LOCAL_VERSION#v}
          REMOTE_CLEAN=${REMOTE_VERSION#v}

          echo "local_version=$LOCAL_VERSION" >> $GITHUB_OUTPUT

          if [ "$LOCAL_CLEAN" == "$REMOTE_CLEAN" ]; then
            echo "Versions match. No update needed."
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "New version found!"
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "version=$REMOTE_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Download & Update Assets
        if: steps.check.outputs.update_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.BRAND_REPO_READ_TOKEN }}
          VERSION: ${{ steps.check.outputs.version }}
        run: |
          set -euo pipefail

          # Ensure cleanup on exit (success or failure)
          trap 'rm -rf temp-download temp-unzip temp-logo-backup' EXIT

          echo "Downloading assets for version $VERSION..."

          # Download the bundle zip from the release
          gh release download "$VERSION" \
            --repo bitcraft-apps/bitcraft-brand \
            --pattern "*brand-bundle*.zip" \
            --dir temp-download

          # Find the downloaded zip file (with validation)
          # nullglob: return empty array instead of literal pattern if no matches
          shopt -s nullglob
          ZIP_FILES=(temp-download/*.zip)
          shopt -u nullglob

          if [ ${#ZIP_FILES[@]} -eq 0 ]; then
            echo "Error: No zip file found in temp-download/"
            exit 1
          fi

          if [ ${#ZIP_FILES[@]} -gt 1 ]; then
            echo "Error: Multiple zip files found: ${ZIP_FILES[*]}"
            exit 1
          fi

          ZIP_FILE="${ZIP_FILES[0]}"
          echo "Downloaded: $ZIP_FILE"

          # Unzip to a staging directory (avoid copying to repo root for security)
          unzip -o "$ZIP_FILE" -d temp-unzip
          STAGING="temp-unzip/bundle"

          # Validate expected bundle structure exists
          if [ ! -d "$STAGING" ]; then
            echo "Error: Expected 'bundle/' directory not found in zip archive"
            echo "Archive contents:"
            ls -la temp-unzip/
            exit 1
          fi

          # Expected bundle structure:
          # bundle/
          #   favicon-16x16.png, favicon-32x32.png, ... (standard files)
          #   brand/
          #     bitcraft-og.png
          #     tokens.css
          #     bitcraft-logo*.svg (optional - see bitcraft-brand#32)

          # 1. Move standard web assets to public/ root
          mkdir -p public
          find "$STAGING" -maxdepth 1 -type f \( -name "favicon*" -o -name "android-chrome*" -o -name "apple-touch-icon.png" -o -name "site.webmanifest" \) -exec mv -f {} public/ \;

          # 2. Handle brand/ subdirectory
          if [ -d "$STAGING/brand" ]; then
             mkdir -p src/styles

             # Move tokens.css to src/styles/
             if [ -f "$STAGING/brand/tokens.css" ]; then
                mv -f "$STAGING/brand/tokens.css" src/styles/
             fi

             # Preserve local logo SVGs if bundle doesn't provide them
             # (logos are manually managed until upstream bitcraft-brand#32 is resolved)
             shopt -s nullglob
             LOCAL_LOGOS=(public/brand/bitcraft-logo*.svg)
             BUNDLE_LOGOS=("$STAGING"/brand/bitcraft-logo*.svg)
             shopt -u nullglob

             if [ ${#LOCAL_LOGOS[@]} -gt 0 ] && [ ${#BUNDLE_LOGOS[@]} -eq 0 ]; then
                mkdir -p temp-logo-backup
                mv "${LOCAL_LOGOS[@]}" temp-logo-backup/
             fi

             # Preserve local README.md (not part of upstream bundle)
             if [ -f "public/brand/README.md" ]; then
                mkdir -p temp-logo-backup
                mv "public/brand/README.md" temp-logo-backup/
             fi

             # Replace public/brand with bundle contents
             rm -rf public/brand
             mkdir -p public/brand

             # Copy brand assets (use nullglob to handle empty directory gracefully)
             shopt -s nullglob
             BRAND_FILES=("$STAGING/brand/"*)
             shopt -u nullglob

             if [ ${#BRAND_FILES[@]} -gt 0 ]; then
                cp -R "${BRAND_FILES[@]}" public/brand/
             else
                echo "Warning: No files found in $STAGING/brand/"
             fi

             # Restore logo SVGs and README if we backed them up
             if [ -d "temp-logo-backup" ]; then
                shopt -s nullglob
                BACKUP_LOGOS=(temp-logo-backup/*.svg)
                shopt -u nullglob
                if [ ${#BACKUP_LOGOS[@]} -gt 0 ]; then
                   mv "${BACKUP_LOGOS[@]}" public/brand/
                fi
                if [ -f "temp-logo-backup/README.md" ]; then
                   mv "temp-logo-backup/README.md" public/brand/
                fi
                rm -rf temp-logo-backup
             fi
          fi

          # Update the local version file (atomic via temp file)
          # Note: temp directories cleaned up by EXIT trap
          TEMP_FILE=$(mktemp)
          jq --arg v "$VERSION" '.version = $v' src/data/brand-version.json > "$TEMP_FILE" && mv "$TEMP_FILE" src/data/brand-version.json

      - name: Create Pull Request
        if: steps.check.outputs.update_needed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore(brand): update assets to ${{ steps.check.outputs.version }}'
          branch: brand-update-${{ steps.check.outputs.version }}
          title: 'chore(brand): update assets to ${{ steps.check.outputs.version }}'
          body: |
            Automated brand asset update detected.

            **Old Version:** ${{ steps.check.outputs.local_version }} (implied)
            **New Version:** ${{ steps.check.outputs.version }}

            This PR was created automatically by the polling workflow.
          delete-branch: true
